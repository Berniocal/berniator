<!doctype html>
<html lang="cs">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<meta name="theme-color" content="#0b1323" />
<title>Berni√°tor ‚Äî gener√°tor 1 periody</title>

<style>
  :root{
    --bg:#0b1323; --bg2:#0f1722; --panel:#101826;
    --text:#e6eef8; --muted:#9fb0c7; --accent:#60a5fa;
    --ok:#22c55e; --danger:#ef4444; --ring:#1f334a;
  }
  *{box-sizing:border-box;-webkit-tap-highlight-color: transparent;}
  html,body{
    height:100%;margin:0;
    background:linear-gradient(180deg,var(--bg),var(--bg2));
    color:var(--text);
    font:16px/1.35 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
  }
  .app{
    min-height:100dvh;display:flex;flex-direction:column;gap:12px;
    padding:12px;padding-top:env(safe-area-inset-top);
    padding-bottom:calc(env(safe-area-inset-bottom) + 12px);
  }
  h1{font-size:18px;margin:2px 0 0 0;text-align:center}
  .hint{margin:0;color:var(--muted);font-size:.9rem;text-align:center}

  .panel{
    background:var(--panel);border-radius:16px;padding:12px;
    box-shadow:0 8px 28px rgba(0,0,0,.35)
  }

  /* ===== Collapsible controls ===== */
  details.controls > summary{
    list-style:none;
    cursor:pointer;
    user-select:none;
    display:flex;align-items:center;justify-content:space-between;
    gap:10px;
    padding:12px 14px;
    border-radius:14px;
    background:#0b1220;
    border:1px solid #1f334a;
    color:var(--text);
    font-weight:800;
  }
  details.controls > summary::-webkit-details-marker{display:none;}
  .chev{opacity:.85;font-weight:900;transition:transform .18s ease}
  details.controls[open] > summary .chev{transform:rotate(180deg)}
  .controlsBody{margin-top:10px}

  .pad-wrap{
    position:relative;border-radius:16px;overflow:hidden;
    background:#0b1220;border:1px solid #1f334a;
    box-shadow:0 8px 28px rgba(0,0,0,.25);
  }
  .pad-wrap #pad{width:100%;height:42vh;display:block;touch-action:none}

  .toolbar{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
  @media (min-width:740px){ .toolbar{grid-template-columns:repeat(6,1fr)} }

  button{
    appearance:none;border:0;border-radius:14px;background:#152236;color:var(--text);
    padding:14px 12px;font-weight:700;font-size:16px;min-height:48px;
    box-shadow:0 2px 0 rgba(0,0,0,.35);
  }
  button:active{transform:translateY(1px)}
  .ok{background:var(--ok);color:#05150a}
  .danger{background:var(--danger);color:#1a0a0a}

  .chipbar{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}
  .chip{
    padding:10px 12px;border-radius:999px;background:#0b1220;border:1px solid #1e293b;
    color:var(--muted);font-size:.9rem;user-select:none;
  }
  .chip.active{background:#1e344f;color:#cfe6ff;border-color:#335d91}

  /* ===== Knob ===== */
  .knob{
    border-radius:18px;
    background:#0b1220;
    border:1px solid #1f334a;
    position:relative;
    min-height:220px;
    aspect-ratio:1/1;
    touch-action:none;
    overflow:hidden;
    display:flex;align-items:center;justify-content:center;
  }
  .knob, .knob *{
    -webkit-user-select:none; user-select:none;
    -webkit-touch-callout:none;
  }
  .knob svg{
    position:absolute; inset:0; width:100%; height:100%;
    z-index:1;
  }

  .knobCenterBtn{
    position:relative;
    z-index:3;
    display:inline-flex;
    align-items:baseline;
    gap:8px;
    padding:10px 14px;
    border-radius:999px;
    background:rgba(11,18,32,.35);
    border:1px solid rgba(31,51,74,.6);
    backdrop-filter: blur(3px);
    font-weight:900;
    font-size: clamp(24px, 6.2vw, 40px);
    letter-spacing:.2px;
    white-space:nowrap;
    cursor:pointer;
  }
  .knobCenterBtn:active{transform:translateY(1px)}
  .knobHint{
    position:absolute; bottom:10px; left:12px;
    z-index:2;
    font-size:1rem;color:var(--muted);
    pointer-events:none;
  }

  .knobEdit{
    position:absolute;
    z-index:4;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,.18);
  }
  .knobEdit.show{display:flex}
  .knobEdit input{
    width:min(260px, 72%);
    text-align:center;
    padding:12px 14px;
    border-radius:14px;
    border:1px solid #335d91;
    background:#0b1220;
    color:var(--text);
    font-size:20px;
    font-weight:800;
    outline:none;
  }

  .playRow{
    margin-top:12px;
    display:flex;
    justify-content:center;
  }
  #btnPlayStop{ width:min(360px, 100%); }

  .footer-note{font-size:.85rem;color:var(--muted);text-align:center;margin-top:8px}
</style>
</head>

<body>
<div class="app">
  <div>
    <h1>Nakresli 1 periodu ‚Üí p≈ôehraj üéß</h1>
    <p class="hint">Graf a ovl√°d√°n√≠ jsou v roletƒõ naho≈ôe. Frekvenci mƒõn√≠≈° knofl√≠kem nebo klepnut√≠m na ƒç√≠slo uprost≈ôed.</p>
  </div>

  <details class="controls" id="controls">
    <summary>
      <span>‚öôÔ∏è Ovl√°d√°n√≠ periody</span>
      <span class="chev">‚ñæ</span>
    </summary>

    <div class="controlsBody">
      <div class="pad-wrap" style="margin-bottom:10px">
        <canvas id="pad"></canvas>
      </div>

      <div class="toolbar" role="toolbar" aria-label="Kreslen√≠">
        <button id="btnDraw" class="chip" aria-pressed="false">‚úèÔ∏è Kreslit</button>
        <button id="btnErase" class="chip" aria-pressed="false">ü©π Vyhladit</button>
        <button id="btnClear" class="chip">üóëÔ∏è Vymazat</button>
        <button id="btnNormalize" class="chip">‚ÜîÔ∏è Normalizovat</button>
        <button id="btnCenter" class="chip">‚öñÔ∏è Bez DC</button>
        <button id="btnInvert" class="chip">‚áÖ Invertovat</button>
      </div>

      <div class="chipbar" id="presets" role="group" aria-label="P≈ôedvolby">
        <div class="chip active" data-preset="sine">Sinus</div>
        <div class="chip" data-preset="square">ƒåtverec</div>
        <div class="chip" data-preset="saw">Pila</div>
        <div class="chip" data-preset="triangle">Troj√∫heln√≠k</div>
        <div class="chip" id="btnHalfRect">P≈Ølvlnn√Ω usmƒõrnƒõn√Ω</div>
      </div>
    </div>
  </details>

  <div class="panel">
    <div id="knob" class="knob" aria-label="Nekoneƒçn√Ω potenciometr frekvence">
      <svg viewBox="0 0 100 100" aria-hidden="true">
        <circle cx="50" cy="50" r="38" fill="none" stroke="var(--ring)" stroke-width="10" opacity="0.9" />
        <g id="trail"></g>
        <circle id="thumb" cx="50" cy="12" r="5.2" fill="#cfe6ff" opacity="0.95"></circle>
      </svg>

      <div id="knobCenterBtn" class="knobCenterBtn" role="button" aria-label="Upravit frekvenci">
        <span id="knobHz">440</span><span style="opacity:.9;font-size:.55em">Hz</span>
      </div>

      <div id="knobEdit" class="knobEdit" aria-hidden="true">
        <input id="knobInput" type="number" inputmode="numeric" min="10" max="5000" step="1" value="440" />
      </div>

      <div class="knobHint">T√°hni po obvodu</div>
    </div>

    <div class="playRow">
      <button id="btnPlayStop" class="ok">‚ñ∂Ô∏è P≈ôehr√°t</button>
    </div>

    <p class="footer-note">Berni√°tor ‚Ä¢ offline</p>
  </div>
</div>

<script>
(() => {
  const TABLE_SIZE = 1024;
  const DRAW_SMOOTH = 0.35;

  const F_MIN = 10, F_MAX = 5000;

  const ONE_TURN_MULT = 3;
  const LOW_ADD_PER_RAD = 6.0;
  const LOW_BLEND_HZ = 120;

  // SVG ring
  const CX=50, CY=50, R=38;
  const HIT_R_IN  = R - 12;
  const HIT_R_OUT = R + 12;

  const TRAIL_ANGLE = 1.9;
  const TRAIL_DOTS = 26;

  let table = new Float32Array(TABLE_SIZE);
  let lastWaveTable = null; // Float32Array normalizovan√°, bez DC

  let tool = null; // 'draw' | 'erase' | null
  let needRedraw = true;

  // audio
  let ctxAudio = null, node = null, usingWorklet = false;
  let osc = null, gain = null;
  let playing = false;

  // frekvence (internƒõ float)
  let freqExact = 440;

  // knob
  let knobActive=false;
  let lastAngle=0;
  let fingerAngle=-Math.PI/2;

  // UI prvky
  const controls = document.getElementById('controls');

  const knob = document.getElementById('knob');
  const svg  = knob.querySelector('svg');
  const trail = document.getElementById('trail');
  const thumb = document.getElementById('thumb');

  const knobHz = document.getElementById('knobHz');
  const knobCenterBtn = document.getElementById('knobCenterBtn');
  const knobEdit = document.getElementById('knobEdit');
  const knobInput = document.getElementById('knobInput');

  // ===== Canvas =====
  const pad = document.getElementById('pad');
  const ctx = pad.getContext('2d') || pad.getContext('2d', { alpha:false });

  function ensureCanvasSize(){
    if (!controls.open) return;
    const cssW = pad.clientWidth || Math.floor(innerWidth);
    const cssH = pad.clientHeight || Math.floor(innerHeight * 0.42);
    const ratio = Math.min(devicePixelRatio||1, 2);
    const w = Math.max(10, Math.floor(cssW*ratio));
    const h = Math.max(10, Math.floor(cssH*ratio));
    if (pad.width !== w || pad.height !== h){
      pad.width = w; pad.height = h;
      needRedraw = true;
    }
  }
  controls.addEventListener('toggle', () => {
    if (controls.open) {
      setTimeout(() => { ensureCanvasSize(); requestDraw(); }, 0);
      setTimeout(() => { ensureCanvasSize(); requestDraw(); }, 120);
    }
  });

  // ===== Wave helpers =====
  function removeDC_inplace(arr){
    let s=0; for(let i=0;i<arr.length;i++) s+=arr[i];
    const m=s/arr.length;
    for(let i=0;i<arr.length;i++) arr[i]-=m;
  }
  function normalize_inplace(arr){
    let m=0; for(let i=0;i<arr.length;i++) m=Math.max(m,Math.abs(arr[i]));
    if(m>1e-9){
      const k=1/m;
      for(let i=0;i<arr.length;i++) arr[i]*=k;
    }
  }

  function rebuildLastWaveTable(){
    const tmp = new Float32Array(table);
    removeDC_inplace(tmp);
    normalize_inplace(tmp);
    lastWaveTable = tmp;
  }

  function setPreset(name){
    for(let i=0;i<TABLE_SIZE;i++){
      const t=i/TABLE_SIZE;
      if(name==='sine') table[i]=Math.sin(2*Math.PI*t);
      else if(name==='square') table[i]=Math.sign(Math.sin(2*Math.PI*t)) || 1;
      else if(name==='saw') table[i]=2*(t - Math.floor(t+0.5));
      else if(name==='triangle') table[i]=1 - 4*Math.abs(Math.round(t-0.25)-(t-0.25));
    }
    rebuildLastWaveTable();
    requestDraw();
    sendTableToAudio(); // ‚úÖ teƒè funguje i za bƒõhu
    document.querySelectorAll('#presets .chip[data-preset]').forEach(c=>c.classList.remove('active'));
    document.querySelector(`#presets .chip[data-preset="${name}"]`)?.classList.add('active');
  }
  setPreset('sine');

  // ===== Drawing =====
  let drawing=false, lastX=0;

  function xyToIdxVal(x,y){
    const rect = pad.getBoundingClientRect();
    const rx = (x - rect.left) / rect.width;
    const ry = (y - rect.top) / rect.height;
    const idx = Math.min(TABLE_SIZE-1, Math.max(0, Math.floor(rx*TABLE_SIZE)));
    const val = Math.min(1, Math.max(-1, (1 - 2*ry)));
    return {idx, val};
  }
  function applyTool(i,v){
    if(tool==='draw') table[i]=v;
    else if(tool==='erase') table[i]=table[i]*(1-DRAW_SMOOTH);
  }
  function pointerDown(ev){
    if(!tool || !controls.open) return;
    drawing=true;
    const p = ev.touches ? ev.touches[0] : ev;
    const {idx,val} = xyToIdxVal(p.clientX,p.clientY);
    lastX=idx;
    applyTool(idx,val);
    requestDraw();
  }
  function pointerMove(ev){
    if(!drawing) return;
    const p = ev.touches ? ev.touches[0] : ev;
    const {idx,val} = xyToIdxVal(p.clientX,p.clientY);
    const i0=Math.min(lastX,idx), i1=Math.max(lastX,idx);
    for(let i=i0;i<=i1;i++){
      const a=(i1===i0)?1:(i-i0)/(i1-i0);
      const v=table[lastX]*(1-a)+val*a;
      applyTool(i,v);
    }
    lastX=idx;
    requestDraw();
  }
  function pointerUp(){
    if(!drawing) return;
    drawing=false;
    rebuildLastWaveTable();
    sendTableToAudio(); // ‚úÖ teƒè se prop√≠≈°e i do fallback oscil√°toru
  }
  pad.addEventListener('touchstart', e=>{ e.preventDefault(); pointerDown(e); }, {passive:false});
  pad.addEventListener('touchmove',  e=>{ e.preventDefault(); pointerMove(e); }, {passive:false});
  pad.addEventListener('touchend',   e=>{ e.preventDefault(); pointerUp(e); }, {passive:false});
  pad.addEventListener('mousedown', pointerDown);
  pad.addEventListener('mousemove', pointerMove);
  addEventListener('mouseup', pointerUp);

  function requestDraw(){ needRedraw=true; }
  function drawNow(){
    if(!needRedraw) return;
    if(!controls.open) return;
    ensureCanvasSize();
    if(!controls.open) return;

    needRedraw=false;

    const w=pad.width, h=pad.height;
    const ratio=Math.min(devicePixelRatio||1,2);

    ctx.clearRect(0,0,w,h);
    ctx.save();

    ctx.strokeStyle='#1e293b';
    ctx.lineWidth=1*ratio;
    ctx.beginPath();
    for(let k=0;k<=8;k++){
      const x=(w/8)*k; ctx.moveTo(x,0); ctx.lineTo(x,h);
    }
    for(let k=0;k<=8;k++){
      const y=(h/8)*k; ctx.moveTo(0,y); ctx.lineTo(w,y);
    }
    ctx.stroke();

    ctx.strokeStyle='#335d91';
    ctx.beginPath(); ctx.moveTo(0,h/2); ctx.lineTo(w,h/2); ctx.stroke();

    ctx.strokeStyle='#60a5fa';
    ctx.lineWidth=2*ratio;
    ctx.beginPath();
    for(let i=0;i<TABLE_SIZE;i++){
      const x=i/(TABLE_SIZE-1)*w;
      const y=(1-(table[i]+1)/2)*h;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    if(!tool){
      ctx.fillStyle='rgba(231,238,248,.86)';
      ctx.font=`${14*ratio}px system-ui,Segoe UI,Roboto,Arial`;
      ctx.textAlign='center';
      ctx.fillText('Kreslen√≠ je vypnut√© ‚Äî zapni ‚úèÔ∏è Kreslit nebo ü©π Vyhladit', w/2, 24*ratio);
    }

    ctx.restore();
  }
  (function loop(){ drawNow(); requestAnimationFrame(loop); })();
  addEventListener('resize', ()=>{ if(controls.open){ ensureCanvasSize(); requestDraw(); } });

  // ===== Toggle kreslen√≠ =====
  const btnDraw=document.getElementById('btnDraw');
  const btnErase=document.getElementById('btnErase');
  function setTool(t){
    tool = t;
    btnDraw.classList.toggle('active', tool==='draw');
    btnErase.classList.toggle('active', tool==='erase');
    btnDraw.setAttribute('aria-pressed', tool==='draw'?'true':'false');
    btnErase.setAttribute('aria-pressed', tool==='erase'?'true':'false');
    requestDraw();
  }
  btnDraw.onclick = ()=> setTool(tool==='draw' ? null : 'draw');
  btnErase.onclick= ()=> setTool(tool==='erase'? null : 'erase');

  document.getElementById('btnClear').onclick=()=>{
    table.fill(0);
    rebuildLastWaveTable();
    requestDraw();
    sendTableToAudio();
  };
  document.getElementById('btnNormalize').onclick=()=>{
    // normalizace na hlavn√≠ tabulce (u≈æiteƒçn√© i pro kreslen√≠)
    normalize_inplace(table);
    rebuildLastWaveTable();
    requestDraw();
    sendTableToAudio();
  };
  document.getElementById('btnCenter').onclick=()=>{
    removeDC_inplace(table);
    rebuildLastWaveTable();
    requestDraw();
    sendTableToAudio();
  };
  document.getElementById('btnInvert').onclick=()=>{
    for(let i=0;i<table.length;i++) table[i] = -table[i];
    rebuildLastWaveTable();
    requestDraw();
    sendTableToAudio();
  };

  document.getElementById('presets').addEventListener('click',(e)=>{
    const el=e.target.closest('.chip[data-preset]');
    if(!el) return;
    setPreset(el.dataset.preset);
  });
  document.getElementById('btnHalfRect').onclick=()=>{
    for(let i=0;i<table.length;i++) table[i] = Math.max(0, table[i]) * 2 - 1;
    rebuildLastWaveTable();
    requestDraw();
    sendTableToAudio();
  };

  // ===== Frekvence =====
  function clampFreqExact(f){
    if(!Number.isFinite(f)) f=freqExact;
    return Math.max(F_MIN, Math.min(F_MAX, f));
  }
  function setFreqExact(f){
    freqExact = clampFreqExact(f);
    const fUi = Math.round(freqExact);
    knobHz.textContent = String(fUi);
    knobInput.value = String(fUi);
    setFrequencyParam(freqExact);
  }

  // ===== Inline edit =====
  function openEdit(){
    knobEdit.classList.add('show');
    knobEdit.setAttribute('aria-hidden','false');
    knobInput.value = String(Math.round(freqExact));
    knobInput.focus({preventScroll:true});
    knobInput.select();
  }
  function closeEdit(commit){
    if(commit){
      const raw=(knobInput.value||'').trim();
      const num=parseInt(raw.replace(/[^\d]/g,''),10);
      if(Number.isFinite(num)) setFreqExact(num);
      else setFreqExact(freqExact);
    }
    knobEdit.classList.remove('show');
    knobEdit.setAttribute('aria-hidden','true');
    knobInput.blur();
  }
  knobCenterBtn.addEventListener('click', (e)=>{ e.stopPropagation(); openEdit(); });
  knobEdit.addEventListener('click', (e)=>{ if(e.target === knobEdit) closeEdit(true); });
  knobInput.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter'){ e.preventDefault(); closeEdit(true); }
    if(e.key === 'Escape'){ e.preventDefault(); closeEdit(false); }
  });
  knobInput.addEventListener('blur', ()=> closeEdit(true));

  // ===== Knob =====
  function angleDelta(a, b){
    let d = a - b;
    while(d > Math.PI) d -= 2*Math.PI;
    while(d < -Math.PI) d += 2*Math.PI;
    return d;
  }
  function angleFromClient(clientX, clientY){
    const r = svg.getBoundingClientRect();
    const x = (clientX - r.left) / r.width * 100;
    const y = (clientY - r.top)  / r.height * 100;
    return Math.atan2(y - CY, x - CX);
  }
  function hitRing(clientX, clientY){
    const r = svg.getBoundingClientRect();
    const x = (clientX - r.left) / r.width * 100;
    const y = (clientY - r.top)  / r.height * 100;
    const dx = x - CX, dy = y - CY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    return dist >= HIT_R_IN && dist <= HIT_R_OUT;
  }
  function pointOnCircle(angle, radius){
    return { x: CX + radius*Math.cos(angle), y: CY + radius*Math.sin(angle) };
  }
  function renderTrail(currentAngle){
    while(trail.firstChild) trail.removeChild(trail.firstChild);
    const a0 = currentAngle - TRAIL_ANGLE;
    const a1 = currentAngle;
    for(let i=0;i<TRAIL_DOTS;i++){
      const t = i/(TRAIL_DOTS-1);
      const a = a0 + (a1-a0)*t;
      const p = pointOnCircle(a, R);
      const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
      c.setAttribute('cx', p.x.toFixed(3));
      c.setAttribute('cy', p.y.toFixed(3));
      c.setAttribute('r', (2.2 + 1.4*t).toFixed(2));
      const op = 0.08 + 0.82*t;
      c.setAttribute('fill', `rgba(96,165,250,${op.toFixed(3)})`);
      trail.appendChild(c);
    }
    const pt = pointOnCircle(currentAngle, R);
    thumb.setAttribute('cx', pt.x.toFixed(3));
    thumb.setAttribute('cy', pt.y.toFixed(3));
  }

  function applyAngleDeltaToFreq(d){
    if(knobEdit.classList.contains('show')) return;

    const w = Math.max(0, Math.min(1, freqExact / LOW_BLEND_HZ));
    const wMul = w*w;
    const wAdd = 1 - wMul;

    const add = d * LOW_ADD_PER_RAD;

    const k = Math.log(ONE_TURN_MULT) / (2*Math.PI);
    const mult = Math.exp(k * d);
    const mulDelta = freqExact * (mult - 1);

    setFreqExact(freqExact + wAdd*add + wMul*mulDelta);
  }

  knob.addEventListener('pointerdown', (e)=>{
    const path = e.composedPath?.() || [];
    if(path.includes(knobCenterBtn) || path.includes(knobInput)) return;
    if(!hitRing(e.clientX, e.clientY)) return;

    knob.setPointerCapture(e.pointerId);
    knobActive = true;

    const a = angleFromClient(e.clientX, e.clientY);
    lastAngle = a;
    fingerAngle = a;
    renderTrail(fingerAngle);

    if(knobEdit.classList.contains('show')) closeEdit(true);
    e.preventDefault();
  });

  knob.addEventListener('pointermove', (e)=>{
    if(!knobActive) return;
    const a = angleFromClient(e.clientX, e.clientY);
    fingerAngle = a;
    renderTrail(fingerAngle);

    const d = angleDelta(a, lastAngle);
    lastAngle = a;
    if(Math.abs(d) > 1e-7) applyAngleDeltaToFreq(d);

    e.preventDefault();
  }, {passive:false});

  function endKnob(){ knobActive=false; }
  knob.addEventListener('pointerup', endKnob);
  knob.addEventListener('pointercancel', endKnob);
  knob.addEventListener('lostpointercapture', endKnob);

  // init
  renderTrail(fingerAngle);
  rebuildLastWaveTable();
  setFreqExact(440);

  // ===== Audio =====
  async function ensureAudio(){
    if(ctxAudio) return;
    ctxAudio = new (window.AudioContext||window.webkitAudioContext)();

    // zkus Worklet
    try{
      const code = `
class WavePlayer extends AudioWorkletProcessor{
  static get parameterDescriptors(){
    return [{name:'frequency',defaultValue:440,minValue:0,maxValue:20000}];
  }
  constructor(){
    super();
    this.table = new Float32Array([0,1,0,-1]);
    this.phase = 0;
    this.port.onmessage = e => {
      if(e.data && e.data.type==='setTable'){
        this.table = new Float32Array(e.data.table);
        this.phase = 0;
      }
    };
  }
  process(inputs, outputs, params){
    const out = outputs[0][0];
    const freq = params.frequency;
    const N = this.table.length;
    for(let j=0;j<out.length;j++){
      const f = (freq.length>1)?freq[j]:freq[0];
      const step = f*N/sampleRate;
      this.phase += step;
      if(this.phase>=N) this.phase -= Math.floor(this.phase/N)*N;
      const i0 = Math.floor(this.phase);
      const i1 = (i0+1)%N;
      const frac = this.phase - i0;
      out[j] = this.table[i0]*(1-frac) + this.table[i1]*frac;
    }
    return true;
  }
}
registerProcessor('wave-player', WavePlayer);
      `;
      const blob = new Blob([code], {type:'application/javascript'});
      const url = URL.createObjectURL(blob);
      await ctxAudio.audioWorklet.addModule(url);

      node = new AudioWorkletNode(ctxAudio,'wave-player',{
        numberOfInputs:0, numberOfOutputs:1, outputChannelCount:[1],
        parameterData:{frequency:freqExact}
      });
      node.connect(ctxAudio.destination);
      usingWorklet = true;

      sendTableToAudio(); // ‚úÖ po vytvo≈ôen√≠ hned po≈°le aktu√°ln√≠ vlnu
      return;
    }catch(_){
      usingWorklet = false;
    }

    // fallback: Oscillator + PeriodicWave
    gain = ctxAudio.createGain();
    gain.gain.value = 0.35;
    gain.connect(ctxAudio.destination);

    osc = ctxAudio.createOscillator();
    osc.frequency.value = freqExact;
    osc.connect(gain);
    osc.start();

    // nastav posledn√≠ vlnu (PeriodicWave)
    sendTableToAudio();
  }

  function setFrequencyParam(f){
    if(!ctxAudio) return;
    const t = ctxAudio.currentTime;
    if(usingWorklet && node){
      node.parameters.get('frequency').setValueAtTime(f, t);
    } else if(osc){
      osc.frequency.setValueAtTime(f, t);
    }
  }

  function buildPeriodicWaveFromTable(tmp){
    // Fourier aproximace (prvn√≠ch 64 harmonick√Ωch)
    const N = tmp.length, K = 64;
    const real = new Float32Array(K+1);
    const imag = new Float32Array(K+1);

    for(let k=1;k<=K;k++){
      let a=0,b=0;
      for(let n=0;n<N;n++){
        const ph = 2*Math.PI*k*n/N;
        a += tmp[n]*Math.cos(ph);
        b += tmp[n]*Math.sin(ph);
      }
      real[k] = (2/N)*a;
      imag[k] = (2/N)*(-b);
    }
    return ctxAudio.createPeriodicWave(real, imag, {disableNormalization:false});
  }

  function sendTableToAudio(){
    if(!lastWaveTable) rebuildLastWaveTable();
    const tmp = lastWaveTable;
    if(!ctxAudio) return;

    if(usingWorklet && node){
      node.port.postMessage({type:'setTable', table: tmp});
      return;
    }

    // fallback
    if(osc && ctxAudio){
      try{
        const pw = buildPeriodicWaveFromTable(tmp);
        osc.setPeriodicWave(pw);
      }catch(_){
        // pokud by PeriodicWave selhalo, nic ‚Äì aspo≈à to hraje
      }
    }
  }

  // ===== ONE Play/Stop =====
  const btnPlayStop = document.getElementById('btnPlayStop');

  function setPlayUI(isPlaying){
    playing = isPlaying;
    if(playing){
      btnPlayStop.classList.remove('ok');
      btnPlayStop.classList.add('danger');
      btnPlayStop.textContent = '‚èπÔ∏è Stop';
    }else{
      btnPlayStop.classList.remove('danger');
      btnPlayStop.classList.add('ok');
      btnPlayStop.textContent = '‚ñ∂Ô∏è P≈ôehr√°t';
    }
  }

  btnPlayStop.onclick = async ()=>{
    if(!playing){
      await ensureAudio();
      if(ctxAudio.state!=='running') await ctxAudio.resume();
      setFrequencyParam(freqExact);
      sendTableToAudio(); // ‚úÖ jistota: p≈ôi startu v≈ædy nastav aktu√°ln√≠ vlnu
      setPlayUI(true);
    }else{
      if(ctxAudio) await ctxAudio.suspend();
      setPlayUI(false);
    }
  };
})();
</script>
</body>
</html>